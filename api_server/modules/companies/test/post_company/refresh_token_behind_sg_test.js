'use strict';

const RefreshTokenTest = require('./refresh_token_test');
const Assert = require('assert');

class RefreshTokenBehindSGTest extends RefreshTokenTest {

	constructor (options) {
		super(options);
		this.serviceGatewayEnabled = true;
	}
	
	get description () {
		return 'under Unified Identity, and running behind Service Gateway, current user should receive an updated New Relic access token and CodeStream access token on their me-channel, after creating a new org';
	}


	// generate the message by issuing a request
	generateMessage (callback) {
		// the message will have already been generated by doCreateCompany(), but it
		// is delayed, so we don't need to do anything here
		callback();
	}

	validateMessage (message) {
		// message should include CodeStream access token, identical to the New Relic access token
		const expectedUser = this.message.user.$set;
		const user = message.message.user.$set;
		const teamId = this.loginResponse.teams[0].id;
		const nrKey = `providerInfo.${teamId}.newrelic`;
		const csKey = 'accessTokens.web';
		Assert.strictEqual(user[`${csKey}.token`], user[`${nrKey}.accessToken`], 'CodeStream access token not equal to New Relic access token');
		expectedUser[`${csKey}.token`] = user[`${nrKey}.accessToken`];
		Assert.strictEqual(user[`${csKey}.refreshToken`], user[`${nrKey}.refreshToken`], 'CodeStream refres token not equal to New Relic refresh token');
		expectedUser[`${csKey}.refreshToken`] = user[`${nrKey}.refreshToken`];
		Assert.strictEqual(user[`${csKey}.expiresAt`], user[`${nrKey}.expiresAt`], 'CodeStream expiration time not equal to New Relic expiration time');
		expectedUser[`${csKey}.expiresAt`] = user[`${nrKey}.expiresAt`];
		Assert.strictEqual(user[`${csKey}.provider`], user[`${nrKey}.provider`], 'CodeStream access token provider not equal to New Relic access token provider');
		expectedUser[`${csKey}.provider`] = user[`${nrKey}.provider`];
		return super.validateMessage(message);
	}
}

module.exports = RefreshTokenBehindSGTest;
